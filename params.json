{"name":"Crash4j","body":"Software testing industry is vast and covers all aspects of product development, with functional and security testing being the most prominent areas of focus in recent years. The purpose of this project is to focus on a less common but increasingly important aspect of software testing - *fault tolerance testing. *\r\n\r\nThe classic fault tolerance testing is performed in the environment, where faults exist or can be emulated. Understanding and measuring system capability to sustain recover or co-exist with a set of faults that could and most often do occur in the production environment is a critical component of the overall system quality. Having this capability has become even more critical with adoption of cloud computing, elastic computing, virtualization and databases that are only eventually consistent. Furthermore, as the number of public data services in the world increases, the applications that, classically only talked to a single network service for local storage purposes are now connecting and communicating with multiple external data providers from within a single user interaction.\r\n\r\nFor example, the application, running within a JVM on top of virtual file system, talking to external remote services, provided by others, and using a data store that is only eventually consistent has to be written and designed in specific way in order to provide a reasonable SLA to its clients from an unstable and unreliable environment.\r\n\r\nCurrently, there are 2 main approaches to this problem. First approach is to modify the environment itself, i.e slow down the network, simulate packet loss within infrastructure, corrupt protocols, drop file systems, etc. These simulations can be done with custom scripts or fault injection software (i.e. Codenomicon, etc) In most situations this approach requires separate test environment and for organizations that have hundreds of applications in the pipeline it becomes prohibitively expensive.\r\n\r\nThe second approach is to simulate faults from within the application itself. This approach requires instrumentation of the application binaries in order to inject the required behavior post deployment. There are a couple of software products in this field (i.e. Exhaustif http://www.exhaustif.es and open source Hadoop Fault Injector http://hadoop.apache.org/hdfs/docs/r0.21.0/faultinject_framework.html). The second approach is more scalable and more financially viable for both: large enterprises as well as startup environments, since the faults are injected into the application and the environment stays unchanged. A serious drawback of all existing solutions that inject faults into application is in the style of fault generation. These solutions use function boundaries as fault injection points and allow the user to inject stochastic behavior around the function execution. However, in reality functions donâ€™t randomly fail, but rather are affected by the environment, so it is the environmental failure that needs to be simulated and then translated into functional behavior. Simulation on function level, assumes that path failures are known, but with fault tolerance the path failures is exactly what we want to find.\r\n\r\nCrash4j introduces a fault-modeling framework that can model environmental failures and misbehaviors, including cascading failures, compile the simulations and make it available for application clients for execution. Once the simulation is within the application runtime, the appropriate controls kick in and execute the simulation, causing the faulty behavior to appear. The simulations will be modeled around resources that application needs, i.e. Network, file system, protocols, databases, queues, .etc but once within the JVM will be translated into the specific API behavior.\r\n\r\nFrom the functional prospective, application implementation will not be aware that the failure is a simulation and will carry on, allowing for the end-user to conduct fault tolerance testing without series environmental impact.\r\n\r\nThe first implementation is being built on top of the JVM and will cover all JVM based languages.","google":"","tagline":"Fault tolerance framework for JVM runtimes ","note":"Don't delete this file! It's used internally to help with page regeneration."}