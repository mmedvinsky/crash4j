<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Crash4j by mmedvinsky</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Crash4j</h1>
        <p>Fault tolerance framework for JVM runtimes </p>

        <p class="view"><a href="https://github.com/mmedvinsky/crash4j">View the Project on GitHub <small>mmedvinsky/crash4j</small></a></p>


        <ul>
          <li><a href="https://github.com/mmedvinsky/crash4j/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mmedvinsky/crash4j/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mmedvinsky/crash4j">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>Software testing industry is vast and covers all aspects of product development, with functional and security testing being the most prominent areas of focus in recent years. The purpose of this project is to focus on a less common but increasingly important aspect of software testing - *fault tolerance testing. *</p>

<p>The classic fault tolerance testing is performed in the environment, where faults exist or can be emulated. Understanding and measuring system capability to sustain recover or co-exist with a set of faults that could and most often do occur in the production environment is a critical component of the overall system quality. Having this capability has become even more critical with adoption of cloud computing, elastic computing, virtualization and databases that are only eventually consistent. Furthermore, as the number of public data services in the world increases, the applications that, classically only talked to a single network service for local storage purposes are now connecting and communicating with multiple external data providers from within a single user interaction.</p>

<p>For example, the application, running within a JVM on top of virtual file system, talking to external remote services, provided by others, and using a data store that is only eventually consistent has to be written and designed in specific way in order to provide a reasonable SLA to its clients from an unstable and unreliable environment.</p>

<p>Currently, there are 2 main approaches to this problem. First approach is to modify the environment itself, i.e slow down the network, simulate packet loss within infrastructure, corrupt protocols, drop file systems, etc. These simulations can be done with custom scripts or fault injection software (i.e. Codenomicon, etc) In most situations this approach requires separate test environment and for organizations that have hundreds of applications in the pipeline it becomes prohibitively expensive.</p>

<p>The second approach is to simulate faults from within the application itself. This approach requires instrumentation of the application binaries in order to inject the required behavior post deployment. There are a couple of software products in this field (i.e. Exhaustif <a href="http://www.exhaustif.es">http://www.exhaustif.es</a> and open source Hadoop Fault Injector <a href="http://hadoop.apache.org/hdfs/docs/r0.21.0/faultinject_framework.html">http://hadoop.apache.org/hdfs/docs/r0.21.0/faultinject_framework.html</a>). The second approach is more scalable and more financially viable for both: large enterprises as well as startup environments, since the faults are injected into the application and the environment stays unchanged. A serious drawback of all existing solutions that inject faults into application is in the style of fault generation. These solutions use function boundaries as fault injection points and allow the user to inject stochastic behavior around the function execution. However, in reality functions donâ€™t randomly fail, but rather are affected by the environment, so it is the environmental failure that needs to be simulated and then translated into functional behavior. Simulation on function level, assumes that path failures are known, but with fault tolerance the path failures is exactly what we want to find.</p>

<p>Crash4j introduces a fault-modeling framework that can model environmental failures and misbehaviors, including cascading failures, compile the simulations and make it available for application clients for execution. Once the simulation is within the application runtime, the appropriate controls kick in and execute the simulation, causing the faulty behavior to appear. The simulations will be modeled around resources that application needs, i.e. Network, file system, protocols, databases, queues, .etc but once within the JVM will be translated into the specific API behavior.</p>

<p>From the functional prospective, application implementation will not be aware that the failure is a simulation and will carry on, allowing for the end-user to conduct fault tolerance testing without series environmental impact.</p>

<p>The first implementation is being built on top of the JVM and will cover all JVM based languages.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/mmedvinsky">mmedvinsky</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>